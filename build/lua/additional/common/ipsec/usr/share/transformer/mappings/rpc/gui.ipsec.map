local logger = require("tch.logger")
local log = logger.new("rpc.gui.ipsec", 4)

local ipsec_status = "/usr/sbin/ipsec status | grep 'Security Associations'"
local ipsec_conf = "/etc/ipsec.conf"
local ipsec_secrets = "/etc/ipsec.secrets"
local gsub, format, match, sub = string.gsub, string.format, string.match, string.sub

local conf_cache = {
  cfg,
  idx,
  time_check, -- time cache was refreshed
  reload -- force reload
}

local function readIPsecConfig()
  local time = os.time()

  if conf_cache.cfg and not conf_cache.reload and ( time - conf_cache.time_check ) < 30 then
    conf_cache.time_check = time
    return conf_cache.cfg, conf_cache.idx
  end

  local index = {}
  local sections = {}

  local section
  local f = io.open(ipsec_conf,"r")
  if f then
    for line in f:lines() do
      local s = match(line, "^(con[%l]+ .*)[%s]*$")
      if s then
        local k = match(s,"[%w]+ (.*)")
        section = #sections + 1
        sections[section] = {
          name = s,
          parameters = {}
        }
        index[k] = section
      else
        local param, value = match(line, "^[%s]+([%w]+)[=%s]*(.*)$")
        if param and value and section then
          sections[section]["parameters"][param] = value
        end
      end
    end
  end
  f:close()

  conf_cache.cfg = sections
  conf_cache.changed = "0"
  conf_cache.idx = index
  conf_cache.time_check = time
  conf_cache.reload = nil

  return sections, index
end

local secret_cache = {
  secrets,
  time_check, -- time cache was refreshed
  reload -- force reload
}

local function readIPsecSecrets()
  local time = os.time()

  -- Use the conf_cache for subsequent request
  if secret_cache.secrets and not secret_cache.reload and ( time - secret_cache.time_check ) < 30 then
    secret_cache.time_check = time
    return secret_cache.secrets
  end

  local lines = {}

  local f = io.open(ipsec_secrets,"r")
  if f then
    for line in f:lines() do
      local s, t, v = match(line, "^[%s]*([%S]*)[%s]*:[%s]*([%w]+)[%s]+\"(.*)\"[%s]*$")
      if v and sub(s,1,1) ~= "#" then
        lines[#lines+1] = {
          selector = s, 
          type = t, 
          secret = v,
        }
      end
    end
  end
  f:close()

  secret_cache.secrets = lines
  secret_cache.time_check = time
  secret_cache.reload = nil

  return lines
end

local GUI_IPSEC_ = {
  objectType = {
    name = "rpc.gui.ipsec.",
    access = "readOnly",
    minEntries = 1,
    maxEntries = 1,
    parameters = {
      apply_changes = {
        access = "readWrite",
        type = "int"
      },
      associations = {
        access = "readOnly",
        type = "string"
      },
      changed = {
        access = "readOnly",
        type = "int"
      },
      reread = {
        access = "readWrite",
        type = "int"
      },
      restart = {
        access = "readWrite",
        type = "int"
      },
    }
  }
}

GUI_IPSEC_.get = {
  apply_changes = function() 
    return "0"
  end,
  associations = function()
    local cmd = io.popen(ipsec_status,'r')
    local status = cmd:read()
    cmd:close()
    return match(status, "%(([^%)]+)")
  end,
  changed = function() 
    readIPsecConfig()
    readIPsecSecrets()
    if conf_cache.changed == "1" or secret_cache.changed == "1" then
      return "1"
    end
    return "0"
  end,
  reread = function() 
    return "0"
  end,
  restart = function() 
    return "0"
  end,
}

GUI_IPSEC_.set = {
  apply_changes = function(mapping, param, value)
    if value == "1" then
      if conf_cache.changed == "1" then
        local f = io.open(ipsec_conf,"w")
        if f then
          local blank_line = "\n"
          local detail_pattern = " %s = %s\n"
          local header_pattern = "%s\n"
          local section
          f:write("# /etc/ipsec.conf - strongSwan IPsec configuration file\n")
          for _,section in pairs(conf_cache.cfg) do
            f:write(format(header_pattern, section.name))
            local option, value
            for option, value in pairs(section.parameters) do
              f:write(format(detail_pattern, option, value))
            end
            f:write(blank_line)
          end
          f:close()
        end
        conf_cache.reload = true
      end
      if secret_cache.changed == "1" then
        local f = io.open(ipsec_secrets,"w")
        if f then
          local selector_pattern = "%s : %s \"%s\"\n"
          local no_selector_pattern = ": %s \"%s\"\n"
          local secret
          f:write("# /etc/ipsec.secrets - strongSwan IPsec secrets file\n")
          for _,secret in pairs(secret_cache.secrets) do
            local selector = match(secret.selector, "^%s*(.-)%s*$")
            if selector == "" then
              f:write(format(no_selector_pattern, secret.type, secret.secret))
            else
              f:write(format(selector_pattern, selector, secret.type, secret.secret))
            end
          end
          f:close()
        end
        secret_cache.reload = true
      end
      os.execute("/etc/init.d/ipsec restart")
    end
  end,
  reread = function(mapping, param, value)
    if value == "1" then
      conf_cache.reload = true
      secret_cache.reload = true
    end
  end,
  restart = function(mapping, param, value)
    if value == "1" then
      os.execute("/etc/init.d/ipsec restart")
    end
  end,
}

register(GUI_IPSEC_)

local GUI_IPSEC_CONN_i_ = {
  objectType = {
    name = "rpc.gui.ipsec.conn.@.",
    access = "readWrite",
    numEntriesParameter = "ConnectionsNumberOfEntries",
    minEntries = 0,
    maxEntries = math.huge,
    parameters = {
      also = {
        access = "readWrite",
        type = "string",
      },
      auto = {
        access = "readWrite",
        type = "string",
      },
      compress = {
        access = "readWrite",
        type = "string",
      },
      type = {
        access = "readWrite",
        type = "string",
      },
      dpdaction = {
        access = "readWrite",
        type = "string",
      },
      dpddelay = {
        access = "readWrite",
        type = "string",
      },
      esp = {
        access = "readWrite",
        type = "string",
      },
      ike = {
        access = "readWrite",
        type = "string",
      },
      keyexchange = {
        access = "readWrite",
        type = "string",
      },
      leftauth = {
        access = "readWrite",
        type = "string",
      },
      leftid = {
        access = "readWrite",
        type = "string",
      },
      leftsubnet = {
        access = "readWrite",
        type = "string",
      },
      rightauth = {
        access = "readWrite",
        type = "string",
      },
      rightauth2 = {
        access = "readWrite",
        type = "string",
      },
      rightsourceip = {
        access = "readWrite",
        type = "string",
      },
    }
  }
}

GUI_IPSEC_CONN_i_.entries = function(mapping)
  local sections, index = readIPsecConfig()
  local res = {}
  local k,v
  for k,v in pairs(index) do
    if v > 1 then
      res[#res+1]=k
    end
  end
  return res
end

GUI_IPSEC_CONN_i_.get = function(mapping, param, key)
  local sections, index = readIPsecConfig()
  local section = index[key]
  return sections[section]["parameters"][param] or ""
end

GUI_IPSEC_CONN_i_.set = function(mapping, param, value, key)
  log:notice("Setting conn key=%s param=%s value=%s",key,param,value)
  local sections, index = readIPsecConfig()
  local section = index[key]
  sections[section]["parameters"][param] = value
  conf_cache.changed = "1"
  return true
end

GUI_IPSEC_CONN_i_.add = function(mapping, key)
  local sections, index = readIPsecConfig()
  local section = #sections + 1
  sections[section] = {
    name = "conn " .. key,
    parameters = {}
  }
  index[key] = section
  conf_cache.changed = "1"
  return key
end

GUI_IPSEC_CONN_i_.delete = function(mapping, key)
  local sections, index = readIPsecConfig()
  local section = index[key]
  sections[section] = nil
  index[key] = nil
  conf_cache.changed = "1"
  return true
end

register(GUI_IPSEC_CONN_i_)

local GUI_IPSEC_SECRET_i_ = {
  objectType = {
    name = "rpc.gui.ipsec.secret.@.",
    access = "readWrite",
    numEntriesParameter = "SecretsNumberOfEntries",
    minEntries = 0,
    maxEntries = math.huge,
    parameters = {
      selector = {
        access = "readWrite",
        type = "string",
      },
      type = {
        access = "readWrite",
        type = "string",
      },
      secret = {
        access = "readWrite",
        type = "string",
      },
    }
  }
}

GUI_IPSEC_SECRET_i_.entries = function(mapping)
  local secrets = readIPsecSecrets()
  local res = {}
  local k,v
  for k,v in pairs(secrets) do
    res[#res+1]=tostring(k)
  end
  return res
end

GUI_IPSEC_SECRET_i_.get = function(mapping, param, key)
  local secrets = readIPsecSecrets()
  return secrets[tonumber(key)][param] or ""
end

GUI_IPSEC_SECRET_i_.set = function(mapping, param, value, key)
  log:notice("Setting secret key=%s param=%s value=%s",key,param,value)
  local secrets = readIPsecSecrets()
  if param == "type" and value ~= "PSK" and value ~= "XAUTH" and value ~= "EAP" and value ~= "RSA" then
    return false
  end
  secrets[tonumber(key)][param] = value
  secret_cache.changed = "1"
  return true
end

GUI_IPSEC_SECRET_i_.add = function(mapping, key)
  local secrets = readIPsecSecrets()
  secrets[#secrets+1] = {
    selector = key, 
    type = "EAP", 
    secret = "password",
  }
  secret_cache.changed = "1"
  return key
end

GUI_IPSEC_SECRET_i_.delete = function(mapping, key)
  local secrets = readIPsecSecrets()
  secrets[tonumber(key)] = nil
  secret_cache.changed = "1"
  return true
end

register(GUI_IPSEC_SECRET_i_)
