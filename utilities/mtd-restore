#!/bin/sh

SCRIPT="$(basename $0)"
VARIANT=$(uci -q get env.var.variant_friendly_name)
VERSION=$(uci -q get version.@version[0].marketing_version)
BOOTED=$(cat /proc/banktable/booted)

usage() {
cat <<EOH
Restores MTD partitions from an attached USB device or SSHFS filesystem. Only changed partitions are restored.

USB devices have priority over SSHFS filesystems. 

Usage: $0 [options] [partition ...]

Options:
 -d directory   The name of the directory on the USB device or SSHFS filesystem containing the backups.
                  If not specified, defaults to: backups or backups-$VERSION
 -f             Restore rootfs_data and $BOOTED
 -U             Download the latest version of $SCRIPT from GitHub
                  Do NOT specify any other parameters or options if doing a version upgrade.
Parameters:
 partition      One or more partitions to restored.
                  Specify either the device (e.g. mtd2) or name (e.g. rootfs_data or data)
                  Do not specify the device variant prefix (e.g. $VARIANT-)
                  If not specified and -f not specified, defaults to mtd2-rootfs_data

EOH
exit
}

upgrade() {
  RESPONSE_CODE=$(curl -kLsI -o /dev/null -w '%{http_code}' https://raw.githubusercontent.com/seud0nym/tch-gui-unhide/master/utilities/$SCRIPT)
  if [ "$RESPONSE_CODE" = 200 ]
  then
    curl -kL -o $SCRIPT https://raw.githubusercontent.com/seud0nym/tch-gui-unhide/master/utilities/$SCRIPT
    if [ $? -eq 0 ]
    then
      chmod +x $SCRIPT
      echo "[$SCRIPT] Successfully downloaded $SCRIPT."
    else
      echo "[$SCRIPT] Failed to download $SCRIPT."
    fi
  elif [ "$RESPONSE_CODE" = 404 ]
  then
    echo "[$SCRIPT] ERROR! Not found on GitHub???"
  elif [ "$RESPONSE_CODE" = 000 ]
  then
    echo "ERROR! No Internet connection???"
  else
    echo "[$SCRIPT] ERROR! Unknown response code $RESPONSE_CODE"
  fi
  exit
}

DIR="backups"
DFLT_RESTORE=""

while getopts :d:fU option
do
 case "${option}" in
  d)  DIR="$(echo $OPTARG | sed -e 's,/$,,')";;
  f)  DFLT_RESTORE="rootfs_data $BOOTED";;
  U)  upgrade;;
  *)  usage;;
 esac
done
shift $((OPTIND-1))

MOUNT_PATH=$(uci get mountd.mountd.path)
USB="$(ls $MOUNT_PATH | head -n1)"
if [ -z "$USB" ]
then
  SSHFS=$(grep -m 1 fuse\.sshfs /proc/mounts | cut -d" " -f2)
  if [ -z "$SSHFS" ]
  then
    echo "$(date +%F@%X): ERROR! No USB device or mounted SSHFS filesystem found"
    exit 2
  else
  SOURCE=${SSHFS}/${DIR}
  fi
else
  SOURCE=${MOUNT_PATH}${USB}/${DIR}
fi

if [ ! -d $SOURCE ]
then
  if [ -d $SOURCE-$VERSION ]
  then
    SOURCE=$SOURCE-$VERSION
  else
    echo "$(date +%F@%X): ERROR! Backup source $SOURCE not found"
    exit 2
  fi
fi

if [ $# -eq 0 -a -z "$DFLT_RESTORE" ]
then
  DFLT_RESTORE="mtd2-rootfs_data"
fi
for p in $DFLT_RESTORE $*
do
  COUNT=$(ls $SOURCE 2>/dev/null | grep -E "$VARIANT-.*$p.*\.img\.gz" | wc -l)
  if [ $COUNT -eq 1 ]
  then
    IMAGES="$IMAGES $(ls $SOURCE 2>/dev/null | grep -E "$VARIANT-.*$p.*\.img\.gz")"
  elif [ $COUNT -eq 0 ]
  then
    echo "$(date +%F@%X): WARNING! Could not find a backup matching $p - IGNORED"
  else
    echo "$(date +%F@%X): WARNING! Found $COUNT backups matching $p - IGNORED"
    ls $SOURCE 2>/dev/null | grep -E "$VARIANT-.*$p.*\.img\.gz" | while read line; do echo "                     -> $line"; done
  fi
done

if [ -z "$IMAGES" ]
then
  echo "$(date +%F@%X): ERROR! No valid backups selected for restore"
  exit 2
fi

IMAGES=$(echo $IMAGES | tr " " "\n" | sort -u | xargs)
echo "$(date +%F@%X): $(echo $IMAGES | wc -w) backups selected for restore:"
for gz in $(echo $IMAGES | tr " " "\n" | sort -u)
do
  echo "                     -> $gz"
done
echo -n "$(date +%F@%X): If you wish to commence the restore, enter y otherwise just press [Enter] to exit. "
read
if [ "$REPLY" != "y" -a "$REPLY" != "Y" ]; then
  exit
fi

for gz in $(echo $IMAGES | tr " " "\n" | sort -u)
do
  echo $gz | grep -q -e '-mtd0-'
  if [ $? -eq 0 ]; then
    echo "$(date +%F@%X): SORRY! You cannot restore mtd0 usng this script"
    continue
  fi

  basename $gz | sed -e "s/^$VARIANT-\(mtd.\)-\(.*\).img.gz$/\1 \2/" | while read -r dev name
  do
    if [ -f $SOURCE/$VARIANT-$dev-$name.img.sha256 ]
    then
      SHA256OLD="$(cat $SOURCE/$VARIANT-$dev-$name.img.sha256 | cut -d' ' -f1)"
    else
      echo "$(date +%F@%X): SKIPPED restore of $gz: $VARIANT-$dev-$name.img.sha256 does not exist?"
      continue
    fi
    echo "$(date +%F@%X): CALCULATING current SHA256 checksum for $name"
    SHA256=$(sha256sum "/dev/${dev}ro" | cut -d' ' -f1)
    if [ "$SHA256" = "$SHA256OLD" ]
    then
      echo "$(date +%F@%X): SKIPPED restore of $gz - Checksums for $name match therefore image unchanged"
    else
      echo "$(date +%F@%X): EXPANDING $name to temporary file $SOURCE/$VARIANT-$dev-$name.img"
      gzip -dc $SOURCE/$gz > $SOURCE/$VARIANT-$dev-$name.img
      echo "$(date +%F@%X): RESTORING $SOURCE/$VARIANT-$dev-$name.img to partion $name"
      mtd write $SOURCE/$VARIANT-$dev-$name.img $name
      if [ $? -eq 0 ]
      then
        echo "$(date +%F@%X): RESTORED $SOURCE/$VARIANT-$dev-$name.img to partion $name"
      else
        echo "$(date +%F@%X): FAILED to restore $SOURCE/$VARIANT-$dev-$name.img to partion $name!"
      fi
      echo "$(date +%F@%X): DELETING expanded temporary file $SOURCE/$VARIANT-$dev-$name.img"
      rm $SOURCE/$VARIANT-$dev-$name.img
    fi
  done
done

echo "$(date +%F@%X): COMPLETED - You may need to manually power cycle the device now..."
